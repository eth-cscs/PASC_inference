		void saveCSV(std::string name_of_file);


template<>
void TSData<PetscVector>::saveCSV(std::string name_of_file){
	LOG_FUNC_STATIC_BEGIN

	Timer timer_saveCSV; 
	timer_saveCSV.restart();
	timer_saveCSV.start();
	
	int nproc = GlobalManager.get_size();
	int my_rank = GlobalManager.get_rank();

	int n,t,k;
	
	int K = get_K();
	int T = get_T();
	int xdim = get_xdim();
	int xmem = get_xmem();
				
	/* to manipulate with file */
	std::ofstream myfile;
						
	/* open file to write */
	std::ostringstream oss_name_of_file_csv;
//	oss_name_of_file_csv << name_of_file << "_p" << my_rank << "_K" << Klocal << "_xmem" << xmemlocal << "_epssqr" << epssqrlocal << ".csv";
	oss_name_of_file_csv << name_of_file << "_p" << my_rank << ".csv";
	myfile.open(oss_name_of_file_csv.str().c_str());

	/* write header to file */
	for(n=0; n<xdim; n++){
		myfile << "x" << n << "_orig,";
	}
	for(k=0; k<K; k++){
		myfile << "gamma" << k << ",";
	}
	for(n=0; n<xdim; n++){
		myfile << "x" << n << "_model";
		if(n+1 < xdim){
			myfile << ",";
		}
	}
	myfile << "\n";

	/* theta */
	double x_model[xdim];
	double *theta_arr;
	TRY( VecGetArray(thetavector->get_vector(),&theta_arr) );

	/* gamma */
	double *gamma_arr;
	TRY( VecGetArray(gammavector->get_vector(),&gamma_arr) );

	/* go through processors and write the sequence into local file */
	int t_in_scatter;
	int t_scatter = this->tsmodel->get_t_scatter();
	int is_begin = 0;
	int is_end = min(is_begin + t_scatter,T);

	Vec x_global = datavector->get_vector();

	const double *x_scatter_arr;
	
	while(is_end <= T && is_begin < is_end){ /* while there is something to scatter */
		/* scatter part of time serie */
		this->tsmodel->scatter_part(x_global, is_begin, is_end, xdim);
				
		TRY( VecGetArrayRead(this->tsmodel->get_x_scatter(), &x_scatter_arr) );
		if(is_begin==0){
			for(t=0;t<xmem;t++){
				/* original time_serie */
				for(n=0;n<xdim;n++){
					myfile << x_scatter_arr[t*xdim+n] << ",";
				}
				/* write gamma vectors */
				for(k=0;k<K;k++){
					myfile << "0,";
				}
				/* new time-serie */
				for(n=0;n<xdim;n++){
					myfile << x_scatter_arr[t*xdim+n];
					if(n+1 < xdim){
						myfile << ",";
					}
				}
				myfile << "\n";
			}
		}

		for(t=is_begin+xmem;t<is_end;t++){
			t_in_scatter = t - is_begin;

			/* compute new time serie from model */
			this->tsmodel->compute_x_model(x_model, x_scatter_arr, t_in_scatter, theta_arr, gamma_arr, t-xmem);

			/* original x */
			for(n=0;n<xdim;n++){
				myfile << x_scatter_arr[t_in_scatter*xdim+n] << ",";
			}

			/* write gamma vectors */
			for(k=0;k<K;k++){
				myfile << gamma_arr[k*(T-xmem)+t-xmem] << ",";
			}
			

			for(n=0;n<xdim;n++){
				myfile << x_model[n];
				if(n+1 < xdim){
					myfile << ",";
				}
			}
			myfile << "\n";
		}
		TRY( VecRestoreArrayRead(this->tsmodel->get_x_scatter(), &x_scatter_arr) );
				
		/* update upper and lower index of scatter_is */
		is_begin = is_begin + t_scatter - xmem;
		is_end = min(is_begin + t_scatter,T);

	}

	TRY( VecRestoreArray(gammavector->get_vector(),&gamma_arr) );
	TRY( VecRestoreArray(thetavector->get_vector(),&theta_arr) );

			
	myfile.close();
	TRY(PetscBarrier(NULL));

	/* writing finished */
	timer_saveCSV.stop();
	coutAll <<  " - problem saved to CSV in: " << timer_saveCSV.get_value_sum() << std::endl;
	coutAll.synchronize();

	LOG_FUNC_STATIC_END
}

